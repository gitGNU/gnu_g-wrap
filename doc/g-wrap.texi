\input texinfo @c -*-texinfo-*-
@c %**start of header
@setfilename g-wrap.info
@settitle G-Wrap
@setchapternewpage on
@c Choices for setchapternewpage are {on,off,odd}.
@paragraphindent 0
@c %**end of header

@dircategory Libraries
@direntry
* G-Wrap: (g-wrap). Scheme wrapper for C libraries
@end direntry

@iftex
@finalout
@c DL: lose the egregious vertical whitespace, esp. around examples
@c but paras in @defun-like things don't have parindent
@parskip 4pt plus 1pt
@end iftex

@titlepage
@title G-Wrap
@subtitle A tool to wrap C APIs for Guile use.
@subtitle Version 1.9.0
@subtitle June 2004
@author Christopher Lee <chrislee@@ri.cmu.edu>
@author Rob Browning <rlb@@defaultvalue.org>
@author Andreas Rottmann <rotty@@debian.org>
@author Ludovic Court�s <ludovic.courtes@@laas.fr>

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 1996, 1997, 1998, 2006 Christopher Lee
Copyright @copyright{} 2000-2001 Rob Browning
Copyright @copyright{} 2004 Andreas Rottmann
Copyright @copyright{} 2005,2006 Ludovic Court�s

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the author.
@end titlepage

@node Top, Copying, (dir), (dir)
@ifinfo

This is the info manual for G-Wrap, covering versions 1.9.*.

@end ifinfo

@menu
* Copying::                     
* Introduction::                
* Usage::                       
* API Reference::               
* Concept Index::               
* Type and Class Index::        
* Procedure and Method Index::  

@detailmenu
 --- The Detailed Node Listing ---

Introduction

* Overview::                    
* Why Create a Wrapper Generator?::  

Usage

* A More Detailed Example::     
* Creating a Wrapper Module::   
* Defining New Wrapped Types::  

API Reference

* Basic Concepts::              
* G-Wrap's High-level API::     
* G-Wrap's Code Generation API::  

Basic Concepts

* Wrapsets::                    
* Wrapped Types::               
* Typespecs::                   
* Wrapped Functions::           

G-Wrap's High-level Interface

* Wrapping a C Function::       
* Wrapping a C Constant::       
* Wrapping an Enumerate Type::  
* Wrapping a C Pointer Type::   
* C Types Provided in the Standard Wrapset::  
* Wrapping Another Simple C Type::  

G-Wrap's Code Generation Interface

* Overview of the Code Generation Methods::  
* The Top-Level Methods::       
* Wrapping and Unwrapping Values::  

@end detailmenu
@end menu

@c Chapter ==================================================================
@node Copying, Introduction, Top, Top
@chapter Copying

@center Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995
@center Free Software Foundation, Inc.
@center 675 Mass Ave, Cambridge, MA 02139, USA

@noindent
Permission to use, copy, modify, distribute, and sell this software and
its documentation for any purpose is hereby granted without fee,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation.

@center NO WARRANTY

@noindent
BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR
THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE
ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH
YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
NECESSARY SERVICING, REPAIR OR CORRECTION.

@noindent
IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR
DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL
DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM
(INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED
INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF
THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR
OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.


@c Chapter ==================================================================
@node Introduction, Usage, Copying, Top
@chapter Introduction

@menu
* Overview::                    
* Why Create a Wrapper Generator?::  
@end menu

@node Overview, Why Create a Wrapper Generator?, Introduction, Introduction
@section Overview

Given a definition of the types and prototypes for a given C interface,
G-Wrap will automatically generate the C code that provides access to
that interface and its types from the Scheme level.

To use G-Wrap, you must make sure it knows how to handle all of the C
types that the functions you will be calling take as arguments and
return as values, and you must also tell G-Wrap about the C prototypes
of these functions.  Since G-Wrap already knows about quite a few of
the common C types, for many simple C APIs, you may not need to add
any custom type specifications.

G-Wrap is implemented as a Guile module, and so its interface is a
programmatic one.  You tell G-Wrap about your functions and types, and
ask it to generate wrappers for you by calling the functions exported
from the @code{(g-wrap)} module.

As a simple example, if you wanted to wrap a C API that contained only
one function with a prototype like this

@example
  int frob(int x, double y);
@end example

@noindent
a complete G-Wrap specification would look like this:

@lisp
(define-module (my-wrapset)
  #:use-module (oop goops)

  #:use-module (g-wrap)        ;; the core of G-Wrap
  #:use-module (g-wrap guile)  ;; defines `<gw-guile-wrapset>'

  #:use-module (g-wrap guile ws standard) ;; the `standard' wrapset

  #:export (<my-wrapset>))

;; Define a wrapset for Guile, and specify the wrapsets
;; it depends on.
(define-class <my-wrapset> (<gw-guile-wrapset>)
  #:id 'my-wrapset
  #:dependencies '(standard))

(define-method (initialize (ws <my-wrapset>) initargs)
  (next-method)

  ;; Populate the wrapset.
  (wrap-function! ws 
                  #:name 'frob
                  #:returns 'int
                  #:arguments '((int x) (double y))
                  #:c-name "frob"
                  #:description "Return the result of frobbing x and y."))
@end lisp

@noindent
You can see that the specification is encapsulated in a Guile module
that exports a class - @code{<my-wrapset>} derived from
@code{<gw-wrapset>}. A wrapset is the G-Wrap counterpart to some API;
it describes how the API looks in C and provides additional
information for the target language. The wrapset above doesn't yet
provide any such information; it is @emph{abstract} and can be refined
for every target language.

In the @code{define-class} statement, the wrapset defines its ID, a
globally unique identifier, and declares a dependency on the
@code{standard} wrapset, which provides the basic C types. In the
@code{initialize} method, the @code{frob} function is wrapped,
providing all relevant data such as return and argument types.

To refine the above wrapset for Guile, you derive from it and add the
necessary information:

@lisp
(define-module (my-guile-wrapset)
  #:use-module (oop goops)
  #:use-module (g-wrap)
  #:use-module (g-wrap guile)
  #:use-module (g-wrap guile ws standard)

  #:export (<my-guile-wrapset>))

(define-class <my-guile-wrapset>
  (<my-wrapset> <gw-guile-wrapset>))

(define-method (initialize (ws <my-guile-wrapset>) initargs)
  ;; Tell parent methods the name the generated Guile module
  ;; should have.
  (next-method ws (append '(#:module (my-module)) initargs)))
@end lisp

We derive our Guile-specific wrapset from the generic wrapset
@code{<my-wrapset>} and the base class for all Guile wrapsets
@code{<gw-guile-wrapset>}. In @code{initialize}, we tell G-Wrap that
the wrapset should eventually reside in the Guile module
@code{my-module}.

@noindent
Once G-Wrap has seen this specification, the code for the wrappers can
be generated with this code:

@lisp
(use-modules (g-wrap) (g-wrap guile) (my-guile-wrapset))

;; Generate wrapper code.
(generate-wrapset 'guile 'my-wrapset "my-wrapset")
@end lisp

@noindent
This will produce the C file @file{my-wrapset.c}, that can be compiled
into a shared library which will, when loaded by Guile, define a
Scheme function named @code{frob} which you can call as expected:

@lisp
  (frob 4 2.3)
@end lisp

When it comes to defining how C types should be handled, G-Wrap is
very flexible.  G-Wrap provides a fairly generic underlying
infrastructure which can then be customized for particular purposes by
teaching it how to generate code for a given type or wrapset.  You can
take explicit control over what code is generated in the wrapper
module to handle arguments and return values of a given type (both for
their initialization and cleanup), what code is generated to handle
the wrapper module's global initialization, and what code is generated
to provide global declarations.

At the lowest level, there is a "wrapping protocol" for types, which
you can plug into to describe how a type is converted from and to the
target language as well as other aspects of the type. G-Wrap comes
with a few of these more types pre-defined.  This set should cover
most of the common cases, but you can extend this set if needed.  The
wrapper types currently available by default include:

@table @samp

@item basic
wrapper types to handle C types which can be represented most
appropriately on the Scheme side by a conversion directly to a native
Scheme type, e.g. @code{double} and @code{char}.

@item non-native
a wrapper type to handle "non-native" objects, that is, C types which
can not, or should not be represented on the Scheme side by a conversion
to a native Scheme representation, or types for which preserving the
C-side pointer equivalency is important.  Instances of this wrapper type
are represented at runtime by a Guile SMOB containing the actual C
pointer.

@item enumeration
a wrapper type to handle C enumerations which automatically grabs the
right C-side values at runtime.

@end table

Furthermore, G-Wrap allows you to define types in one wrapper module
that can then be used by other wrapper modules.  So as an example, you
should be able to define a GLib wrapper module that provides wrapper
specifications for @code{GList*}'s that other wrapper modules can then
import and use in their own wrapper function prototypes for argument
and result types.  The goal is for this to allow different wrapper
modules to be able to safely exchange data among their wrapped
functions when they share common wrapped types.

As mentioned, G-Wrap itself is implemented as purely Scheme-code Guile
modules.  This means that you you can wrap functions for multiple
modules on the fly from any invocation of Guile.

@node Why Create a Wrapper Generator?,  , Overview, Introduction
@section Why Create a Wrapper Generator?

When accessing a given foreign API from a variety of target languages,
the description of the foreign API is a common bit of information that
will be needed by the infrastructure supporting each of the target
languages.  Further, since the internal mechanisms by which a given
target language can access a foreign API are often in flux, it makes
sense to consider automatically generating the "glue code" that binds
the library API and the target language together.  This means that
whenever the foreign function access mechanisms in a target language
change, only G-Wrap (or some similar tool) will need to be updated.
Then all of the relevant glue code can be trivially re-generated.  This
is the job that G-Wrap was designed to handle.

In truth, one of the primary goals of G-Wrap is also to acumulate as
many language independent definitions of various APIs as possible, so
that interfaces for other languages may be generated automatically,
whether by G-Wrap, or some other program.

The original motivation for G-Wrap came from Aubrey Jaffer's suggestion
to Christopher Lee that using Scheme to parse a language neutral API
specification and generate glue code would be a good way to address this
problem for Scheme interpreters.  G-Wrap may well evolve beyond that to
support other languages, but for now, it only handles access to C APIs
from Guile.

In fact, the original implementation of G-Wrap was much more declarative
than programmatic.  The API specification files were not executable
Scheme code, but rather declarative Scheme forms.  In the long run, this
might be preferable, if G-Wrap decides to move in the direction of
language independence, or an alternate possibility is to design a
language neutral API spec file (as gnome-guile is trying to do) and then
just have a translator from that to native G-Wrap calls.

G-Wrap can be found at @url{http://www.nongnu.org/g-wrap/}.

@c Chapter ==================================================================
@node Usage, API Reference, Introduction, Top
@chapter Usage

This section is a guided tour through G-Wrap programmatic interface
that will get you started quickly by looking at practical examples.
For a more detailed view of the API, please see @xref{API Reference}.

@menu
* A More Detailed Example::     
* Creating a Wrapper Module::   
* Defining New Wrapped Types::  
@end menu

@node A More Detailed Example, Creating a Wrapper Module, Usage, Usage
@section A More Detailed Example

In this chapter we'll walk through the process of wrapping an
increasingly complex C API.  In the process, we'll try to hit all the
important G-Wrap features.

You'll see how to define a wrapset, add new types to it (when the
default set of types isn't sufficient), wrap the C-side functions, and
then generate the Guile wrapper code from the wrapset definition.

To start, let's presume you want to wrap a C interface that initially
looks like this:

@example

  char*  join_strings(char *a, char *b);
  double seconds_since_dow(unsigned int day_of_the_week);

@end example

@noindent
and you want to call your wrapset ``miscutils''.

To define your module, you need to create a wrapper specification,
which normally consists of deriving from the @code{<gw-wrapset>} class
and providing an @code{initialize} method that adds the to-be-wrapped
functions and types.  Conventionally, if you're creating a wrapper
module named "foo", the wrapset specification file would be named
foo-spec.scm, or placed in separate @file{ws/} subdirectory.

@node Creating a Wrapper Module, Defining New Wrapped Types, A More Detailed Example, Usage
@section Creating a Wrapset

Inside the wrapset specification file, the first thing you have to do
is create the wrapset class (for a detailed explanation, refer to
@pxref{Wrapsets}).  But before that, you have to tell Guile that
you'll use the GOOPS and G-Wrap modules. So the most trivial wrapper
module possible would look something like this:

@lisp
  (use-modules (oop goops) (g-wrap) (g-wrap guile))

  (define-class <miscutils-wrapset> (<gw-guile-wrapset>)
    #:id 'miscutils)

  (define-method (initialize (ws <miscutils-wrapset>) initargs)
    (next-method ws (append '(#:module (miscutils)) initargs)))
@end lisp

Note how the Guile module that the wrapset should reside in is passed
to the @code{next-method} of @code{initialize} as a keyword argument.

However, this wrapset won't let you do much.  In particular, a newly
created wrapset doesn't know about any wrapped types.  In general
you'll probably want to be able to use the standard set of G-Wrap
wrapped types which include support for int, double, strings, etc.  If
so, then you need to add a @code{#:dependencies} keyword argument to
the class definition:

@example
  (define-class <miscutils-wrapset> (<gw-guile-wrapset>)
    #:id 'miscutils
    #:dependencies '(standard))
@end example

Now you can start wrapping functions using the default set of wrapped
types with calls to @code{wrap-function!}.  To wrap
@code{join_strings} and @code{seconds_since}, you would
want to say something like this:

@example
  (define-method (initialize (ws <miscutils-wrapset>) initargs)
    (next-method ws (append '(#:module (miscutils)) initargs))

    (wrap-function! 
      ws
      #:name 'join_strings
      #:returns 'mchars
      #:c-name "join_strings" 
      #:arguments '((mchars a) (mchars b))
      #:description "Return a string consisting of a followed by b.")

    (wrap-function!
     ws
     #:name 'seconds-since-dow
     #:returns 'double
     #:c-name "seconds_since_dow" 
     #:arguments '((uint day-of-week))
     #:description "Given day-of-week (ranging 1-7), return elapsed time since then."))
@end example

@code{wrap-function!}'s arguments should be quite obvious.  They are
detailed in @xref{Wrapping a C Function}.

Actually, the example given above won't work because specifying
@code{mchars} (roughly G-Wrap's type for @code{char*}, @pxref{C Types
Provided in the Standard Wrapset}) alone doesn't
provide enough information about the allocation semantics of the
argument or return value.  G-Wrap needs to know whether a @code{char*}
argument that's passed in to a function should be considered to be
"owned" by the function after the C function returns, or should be
considered caller owned, and hence safe for deletion if appropriate.
So G-Wrap requires you to be explicit, and provides two type options
for string type arguments and return values: @code{caller-owned} and
@code{callee-owned}.  The "m" in @code{mchars} stands for
@code{malloc}, since it's conceivable that for some C functions, the
argument or result might need to be allocated/freed via some other
mechanism.

So, for our example API, let's presume that @code{join_strings} takes
two strings that are owned by the caller and returns a newly allocated
string that will also be owned by the caller.  Given that, the correct
way to wrap this function is:

@example
    (wrap-function! 
      ws
      #:name 'join-strings
      #:returns '(mchars caller-owned)
      #:c-name "join_strings" 
      #:arguments '(((mchars caller-owned) a) ((mchars caller-owned) b))
      #:description "Return a string consisting of a followed by b.")
@end example

At this point, we have a wrapset named "miscutils" that wraps our two
C functions so that when the wrapper module's C code is generated,
compiled, and then loaded back into Guile, we should be able to call
these C functions normally.  You could use it like this:

@example
  guile> (use-modules (miscutils))
  guile> (join-strings "out" "let")
  "outlet"
  guile> (seconds-since-dow 1)
  3099.232
  guile>
@end example

@node Defining New Wrapped Types,  , Creating a Wrapper Module, Usage
@section Defining New Wrapped Types

Though G-Wrap already provides a number of wrapped types in the
standard wrapset, there will be many cases where you will need to
define your own wrapped types.

As an example, let's presume someone has added a fine-grained, wide
ranging, time type to miscutils along with a function that uses that
type like this:
 
FIXME: Add an overview of how G-Wrap thinks about types -- i.e. using a
template-like process with ccodegens inserting content in important
places.

@example
 
  typedef struct @{
    long long seconds;
    long int nanoseconds;
  @} Timespec64;

  Timespec64 elapsed_time(Timespec64 start, Timespec64 finish);

@end example

and let's further presume that we've decided that you want to represent
@code{Timespec64} values on the scheme side using a cons pair where the
car will be the seconds and the cdr will be the
nanoseconds.@footnote{Though you should probably consider using the time
type from SRFI-19 @url{http://srfi.schemers.org/srfi-19/} instead.}

Since you've decided to use a native Scheme representation for the
type, you'll want to define it as an instance of the G-Wrap "normal"
or "native" wrapper type.  This primarily involves telling G-Wrap how
to translate from the C representation of the type to the Scheme
representation and vice-versa.

The way you do this, is by declaring your new wrapped type and
specifying a set of C-code generator functions (or "codegens") that
will handle producing the C code inside your function wrappers that will
handle the translations.

The first thing you need for your new type is a G-Wrap name.  For this
example, we'll use @code{timespec64}.

To begin, you have to define a new class for your type. We derive it
from @code{<gw-type>}@footnote{If the wrapped type is not an aggregate
value (e.g. a pointer type), @code{<gw-rti-type>} can (and should) be
used instead of the more generic @code{<gw-type>}. When
@code{<gw-rti-type>} is used, G-Wrap is able to use shared conversion
functions and not emit code for each wrapper function, in most cases,
which can considerably reduce the emitted code size}.

@lisp
  (define-class <timespec64-type> (<gw-type>))
@end lisp

Then you can add your new type to your wrapset.  Presume that the
following code is inside the body of the @code{initialize} method of
our previous examples;  i.e. @code{ws} is bound to the miscutils
wrapset you're creating.

@findex add-type!
@lisp
    (add-type! ws (make <timespec64-type> #:name 'timespec64))
@end lisp

We also specialize @code{c-type-name} for our type, so G-Wrap knows
about the C name of the type:

@findex c-type-name
@lisp
(define-method (c-type-name (type <timespec64-type>) (typespec <gw-typespec>))
  "Timespec64")
@end lisp

In order to make this type useful, you have to define some relevant
codegen methods.  Let's start with one that will tell G-Wrap how to
``unwrap'' instances of this type that are passed in as arguments from
the Scheme side.

@findex unwrap-value-cg
@lisp
  (define-method (unwrap-value-cg (type <timespec64-type>)
                                  (value <gw-value>) error-var)
    (list
      "if (SCM_FALSEP(msu_scm_timespec64_p(" (scm-var value) ")))"
      `(gw:error ,error-var type ,(wrapped-var value))
      "else\n"  
      "  " (var value) " = msu_timespec64_to_c(" (scm-var value) ");\n"))
@end lisp

A codegen returns a list where each element in the list may either be
a sub-list or a string, basically a tree of strings.  In the end, this
list will be flattened into one long string and inserted into the C
code being generated for the wrapper module.

The @code{unwrap-value-cg} is called with the type that should be
``unwrapped'', the actual value, which consists of a Scheme and a C
variable. As you can see this codegen grabs the Scheme name and the C
names of the value and then assignes the C value to be the result of
converting the scheme value with the hypothetical
@code{msu_timespec64_to_scm} function.

The list produced by @code{unwrap-value-cg} contains a special
sublist, starting with @code{gw:error}. This indicates a failure
condition, which is checked in the generated code and acted upon
properly (i.e. raising an ``argument type'' error).

The above codegen presumes that the C function
@code{msu_scm_timespec64_p} has been defined and returns non-zero if
the given SCM is a pair and both elements are integers.

At this point G-Wrap knows how to convert and incoming Scheme
arguments, but it doesn't know how to convert from C values to Scheme,
which is needed if you return a Timespec64. To teach it, you need to
define the @code{wrap-value-cg} for @code{<timespec64-type>}, which
has the duty to ``wrap'' the C value for Scheme.

So in our Timespec64 example, we might define our unwrap codegen like
this:

@lisp
  (define-method (wrap-value-cg (type <timespec64-type>)
                                (value <gw-value>) error-var)
    (list
      (scm-var value) " = msu_timespec64_to_scm(" (var value) ");\n"))
@end lisp

There are a bunch of codegens you can define for a type but if you do
nothing overly fancy, you can get away with just @code{wrap-value-cg},
@code{unwrap-value-cg}. For C values that need deconstruction, there
is also @code{destruct-value-cg}.

@c Chapter ==================================================================
@node API Reference, Concept Index, Usage, Top
@chapter API Reference

This section is trying to provide a reference for the most important
parts for G-Wrap's programming.  Since G-Wrap uses a programmatic
approach to interface wrapping, its API is really what allows users to
describe interfaces and types to be wrapped and is a crucial point.

G-Wrap's API can be divided in a higher-level API and a lower-level
code generation interface.  The former is simple, expressive, and
sufficient for many uses of G-Wrap.  The latter gives access to the
full code generation mechanisms of G-Wrap and allows for fine-grain
customization.  Each of these APIs will be exposed in detail in the
following sections.

In any case, reading the section @xref{Basic Concepts}, is highly
recommended since it describes concepts used throughout G-Wrap.

@menu
* Basic Concepts::              
* G-Wrap's High-level API::     
* G-Wrap's Code Generation API::  
@end menu

@node Basic Concepts, G-Wrap's High-level API, API Reference, API Reference
@section Basic Concepts

G-Wrap's APIs are centered around a few basic concepts that one should
know before using them.  Basically, each concept has a corresponding
GOOPS class (see @inforef{Introduction, an introduction to GOOPS,
goops}, for details about GOOPS) usually exported by the
@code{(g-wrap)} module.

@menu
* Wrapsets::                    
* Wrapped Types::               
* Typespecs::                   
* Wrapped Functions::           
@end menu

@node Wrapsets, Wrapped Types, Basic Concepts, Basic Concepts
@subsection Wrapsets

@cindex wrapset
@tindex <gw-wrapset>
A wrapset is roughly an object that holds a representation of all the
C types, constants, and functions what one is willing to ``wrap''.
Wrapset specifications as seen in @xref{Overview}, are in fact a piece
of Scheme code that creates a wrapset object, adds a number of C
functions, types, etc. to be wrapped and then generates code for this
wrapset.  The code generation phase will be described in more details
in @xref{G-Wrap's Code Generation API}.

@cindex <gw-guile-wrapset>
Wrapset are instances of the @code{<gw-wrapset>} class.  Since G-Wrap
can generate code for more than one implementation (at least
theoretically), each particular back-end defines a sub-class of this
class.  For instance, the Guile back-end defines the
@code{<gw-guile-wrapset>} class in the @code{(g-wrap guile)} module.

When creating your own wrapset, you will have to create a sub-class of
@code{<gw-wrapset>} with appropriate parameters, and then instantiate
it.  For instance, you may write:

@smalllisp
(define-class <my-new-wrapset> (<gw-guile-wrapset>)
  #:id 'my-new-wrapset
  #:dependencies '(standard my-other-wrapset))
@end smalllisp

@cindex standard wrapset
This creates a new wrapset for Guile, whose name is
@var{my-new-wrapset} and which depends on the @code{standard} wrapset
(@pxref{C Types Provided in the Standard Wrapset}) and on the wrapset
named @code{my-other-wrapset}.  Each of the wrapset
@code{<my-new-wrapset>} depends on must be visible at this point,
typically by using the modules that define them:

@smalllisp
(use-modules (g-wrap ws standard) ;; the standard wrapset
             (my-other-wrapset))
@end smalllisp

Of course, the module that defines @code{<my-other-wrapset>} does not
need to be called @code{(my-other-wrapset)} but sticking to this
naming scheme is usually a good idea.

The main methods that apply to @code{<gw-wrapset>} objects are listed
below.  Note that if you are simply willing to use G-Wrap's high-level
API (@pxref{G-Wrap's High-level API}), you certainly do not need to
know them, except @code{initialize}.

@deffn method initialize (wrapset <gw-wrapset>) . args
Initialize @var{wrapset}, an newly created instance of
@var{<gw-wrapset>}.  This method is part of the GOOPS meta-object
protocol (see @inforef{Instance Creation, GOOPS MOP specification,
goops}, for details).

@cindex module
@cindex Guile module
Since you will actually always use your own sub-class of
@code{<gw-wrapset>} (e.g. @code{<my-new-wrapset>}), you will want to
specialize this method in order to perform initialization steps which
are specific to your wrapset.  In particular, this is where you will
add new wrapped types, add wrapped functions, specify a Guile module
name and a shared library name:

@lisp
(define-method (initialize (ws <my-new-wrapset>) initargs)

  ;; Invoke the initialization method of the parent class, passing it
  ;; the @code{#:module} and @code{#:shlib-path} initialization
  ;; arguments.  Note that these two parameters are valid only if
  ;; <my-new-wrapset> is a subclass of <gw-guile-wrapset>.

  (next-method #:append '(#:module (my module)
                          #:shlib-path "libguile-my-module")
                        initargs)

  ;; Add a wrapped type.
  (add-type! ws ...)

  ;; and another one...
  (wrap-simple-type! ws ...)

  ;; and a wrapped function...
  (wrap-function! ws ...))
@end lisp

The tutorial contains more detailed examples of this, see
@xref{Creating a Wrapper Module}.

@end deffn

@deffn method name (wrapset <gw-wrapset>)
Return the name (a symbol) of wrapset @var{wrapset}.  The name of a
wrapset is the one that was passed as a @code{#:id} named parameter to
that wrapset's call to @code{initialize}.
@end deffn

@deffn method language (wrapset <gw-wrapset>)
Return the language run-time (a symbol, e.g. @code{guile}) this
wrapset is targeting.
@end deffn

@deffn method wrapsets-depended-on (wrapset <gw-wrapset>)
Return a list of @code{<gw-wrapset>} instances representing the
wrapsets @var{wrapset} depends on.  This wrapsets correspond to those
named in the @code{#:dependencies} named parameter that was passed
when defining a sub-class of @code{<gw-wrapset>} (see above).
@end deffn

@deffn method add-type! (ws <gw-wrapset>) (type <gw-type>)
Add the wrapped type @var{type} to the list of wrapped type of
@var{ws}.
@end deffn

@deffn method add-function! (ws <gw-wrapset>) (function <gw-function>)
Add the wrapped function @var{function} to the list of functions
wrapped by @var{ws}.
@end deffn

@deffn method add-constant! (ws <gw-wrapset>) (constant <gw-constant>)
Add the wrapped constant @var{constant} to the list of constants
wrapped by @var{ws}.
@end deffn

@deffn method for-each-type proc (ws <gw-wrapset>)
For each type (i.e. @code{<gw-type>} instance) wrapped by @var{ws}
call @var{proc} (a procedure or generic function).  The result is
unspecified.
@end deffn

@node Wrapped Types, Typespecs, Wrapsets, Basic Concepts
@subsection Wrapped Types

@tindex <gw-type>
Wrapped types are instances of the @code{<gw-type>} class and hold
information about a C type being wrapped and how to wrap it.  In
@xref{G-Wrap's High-level API}, you will see examples of sub-classes
of @code{<gw-type>} dedicated to wrapping certain C types, such as
pointers, integers, strings, etc.

Besides C code generation methods, a number of methods apply to all
instances of @code{<gw-type>}.  Code generation methods are described
separately, in section @xref{G-Wrap's Code Generation API}.

@deffn method name (type <gw-type>)
Return a symbol denoting the Scheme name for wrapped type @var{type}.
@end deffn

@deffn method class-name (type <gw-type>)
FIXME
@end deffn

@deffn method needs-result-var? (type <gw-type>)
FIXME
@end deffn

@deffn method arguments-visible? (type <gw-type>)
FIXME
@end deffn

@deffn method default-c-value-for-type (type <gw-type>)
On success, return a string that represents some default C value for
@var{type} (e.g., @code{"NULL"} if @var{type} is a pointer type).
This is useful, for instance, to generate C code where no variable is
left uninitialized.  If no default C value is known for @var{type},
then @code{#f} is returned.
@end deffn

@cindex run-time type information
@cindex RTTI
@cindex RTI

Wrapped C types in G-Wrap are broadly separated into two classes:
those for which information is available at run-time, and those for
which this is not the case.  @dfn{Run-time type information} (or
@dfn{RTTI}, or @dfn{RTI}, whichever you prefer) allows G-Wrap's
support run-time libraries to manipulate C objects whose type they
only know at run-time.  In particular, this allows those libraries to
@emph{construct} C function calls at run-time, instead of letting
generated code do this (@pxref{Wrapped Functions}).

@tindex <gw-rti-type>
Wrapped types for which information is available at run-time are
represented by the @code{<gw-rti-type>} class (a sub-class of
@code{<gw-type>}), defined in @code{(g-wrap rti)}.  Actually, most of
the C types wrapped by G-Wrap's standard wrapset (@pxref{C Types
Provided in the Standard Wrapset}) are sub-classes of this class.
Ranged integers, wrapped C pointers (@pxref{Wrapping a C Pointer
Type}), strings, @emph{are} RTI types.  Even user-defined so-called
@dfn{simple types} (see @pxref{Wrapping Another Simple C Type})
inherit from @code{<gw-rti-type>}: all the user needs to do is pass
the appropriate run-time type specification, via the @code{#:ffspec}
option.

A number of additional methods are defined for instances of
@code{<gw-rti-type>}:

@deffn method allowed-options (type <gw-rti-type>)
FIXME
@end deffn

@deffn method c-type-name (type <gw-rti-type>)
Return a string representing the name of the C type wrapped by
@var{type}.
@end deffn

@deffn method c-const-type-name (type <gw-rti-type>)
Return a string representing the @code{const}-qualified version of the
C type wrapped by @var{type}.
@end deffn

@cindex libffi
@deffn method ffspec (type <gw-rti-type>)
Return a symbol denoting run-time type information for the C type
wrapped by @var{type}.  This symbol corresponds to a type tag
understandable by libffi (@pxref{Wrapping Another Simple C Type}).
@end deffn

@deffn method wrap-value-function-name (type <gw-rti-type>)
@deffnx method unwrap-value-function-name (type <gw-rti-type>)
@deffnx method destroy-value-function-name (type <gw-rti-type>)
Return a string denoting the name of the C function that wraps,
unwraps, or destroys instances of the C type wrapped by @var{type}
(see @xref{Wrapping Another Simple C Type}, for details).
@end deffn



@node Typespecs, Wrapped Functions, Wrapped Types, Basic Concepts
@subsection Typespecs

@tindex <gw-typespec>
FIXME: Write it; see also @xref{Wrapping a C Function}.


@node Wrapped Functions,  , Typespecs, Basic Concepts
@subsection Wrapped Functions

@tindex <gw-function>
@cindex RTTI
@cindex RTI
@cindex libffi

@deffn method uses-rti-for-function? (wrapset <gw-rti-wrapset>) (function <gw-function>)
FIXME: Describe
@end deffn

@node G-Wrap's High-level API, G-Wrap's Code Generation API, Basic Concepts, API Reference
@section G-Wrap's High-level Interface

G-Wrap's high-level API lives in the @code{(g-wrap)} module, and
partly in the @code{(g-wrap c-types)} module.  These may be loaded
using:

@lisp
(use-modules (g-wrap)
             (g-wrap c-types))
@end lisp

The procedure it provides have a rather declarative style.  This makes
them easy to use.  On the other hand, it does not leave much room for
customization.  Fine-grain customization of the wrapping generation,
however, may be achieved using the lower-level code generation API
(@pxref{G-Wrap's Code Generation API}).

@menu
* Wrapping a C Function::       
* Wrapping a C Constant::       
* Wrapping an Enumerate Type::  
* Wrapping a C Pointer Type::   
* C Types Provided in the Standard Wrapset::  
* Wrapping Another Simple C Type::  
@end menu

@node Wrapping a C Function, Wrapping a C Constant, G-Wrap's High-level API, G-Wrap's High-level API
@subsection Wrapping a C Function

As seen in @xref{Overview}, wrapping a C function using G-Wrap's
high-level functions is relatively simple.  Essentially, it boils down
to a call to the @code{wrap-function!} GOOPS method.

@deffn method wrap-function! (wrapset <gw-wrapset>) . args
Add the C function described by @var{args} to the list of functions to
be wrapped by @var{wrapset}.  The arguments in @var{args} must contain
the following named parameters (@inforef{Optional Arguments,
@code{(ice-9 optargs)}, guile}, for more information):

@c FIXME: This is (mostly) copied from the `Overview' section.
@table @code
@item #:name
the symbol which should be bound to the wrapped function in Scheme at
runtime.
@item #:returns
the symbol naming the G-Wrap wrapped type of the C function result.
@item #:c-name
a string giving the C function's name.
@item #:arguments
a list of the C function's arguments where each element is of the form
(more details below).
@item #:description
a string describing the function; this string may contain Texinfo
markup.
@end table

@cindex argument specifier
The argument list which is passed as the @code{#:arguments} named
parameter consists of a list of @dfn{argument specifiers}.  Each
argument specifier is itself a two-element list where:

@cindex type specifier
@itemize
@item the first element is a @dfn{type specifier};
@item the second element is a symbol that names the parameter.
@end itemize

The type specifier may in turn be one of the following:

@cindex memory management
@cindex type qualifier
@cindex typespec
@cindex wrapped type
@itemize
@item a symbol naming a wrapped type;
@item a list containing a symbol naming a wrapped type and @dfn{type
qualifier} (in G-Wrap's code, this is usually referred to as a
@dfn{typespec}, although this name is quite unfortunate); the type
qualifier may be one of:

@table @code
@item in
if the parameter in question is an input parameter;
@item out
if the parameter in question is an output parameter;
@item caller-owned
if the parameter in question is a C pointer that points to memory
controlled by the caller;
@item callee-owned
if the parameter in question is a C pointer that points to memory
whose control is passed to the callee (FIXME: give an example);
@item null-ok
if the Scheme input parameter is to be converted to a C pointer, then
let G-Wrap know that @code{#f} is a valid value for this parameter;
@code{#f} will translate to the @code{NULL} pointer in C;
@item aggregated
if the parameter in question points to a C object that is
@dfn{aggregated} by the object returned by the function being wrapped
(more on this below).  By @dfn{object returned}, we mean a wrapped C
pointer or WCP (@pxref{Wrapping a C Pointer Type}) that is either
the return value or an @code{out} argument.
@end table

@end itemize

To illustrate this, here is an example of a valid argument description
list (type @code{mchars} will be detailed later on, @pxref{C Types
Provided in the Standard Wrapset}):

@smalllisp
'(((mchars null-ok caller-owned) input-string)
  (long input-integer)
  ((double out) output-floating-point))
@end smalllisp

@end deffn

Examples of valid usage patterns of @code{wrap-function!} are
available in @xref{Creating a Wrapper Module}.


@unnumbered The @code{aggregated} Type Qualifier

@cindex memory management
@cindex aggregated object
@cindex constructor
The @code{aggregated} type qualifier is mostly useful when wrapping C
functions (constructors) that return a new object which aggregates
objects passed as its input parameters.  In order to illustrate the
need for this typespec, let's imagine the following C API:

@smallexample
/* Return a new stuff.  */
stuff_t *make_stuff (void);

/* Return a stuff container that contains a pointer to CONTAINED.
   Note that the container returned is _not_ responsible for
   deallocating the resources attached to CONTAINED.  */
stuff_container_t *make_stuff_container (stuff_t *contained);
@end smallexample

And now, imagine the following Scheme code that uses bindings of the
above functions:

@smalllisp
(define c (make-stuff-container (make-stuff)))
@end smalllisp

Suppose the two C types are wrapped as WCTs (@pxref{Wrapping a C
Pointer Type}).  The call to @code{make-stuff} will create a new
Scheme object (a WCP, or a ``SMOB'' in Guile terms, @inforef{Defining
New Types (Smobs), SMOBs, guile}, for details) for the underlying C
object.  However, as soon as @code{make-stuff-container} has returned,
the Scheme code no longer holds any SMOB representing the value that
was returned by @code{make-stuff}.  Consequently, the SMOB returned by
@code{make-stuff} may soon be garbage-collected by Guile, and its
underlying C object (originally returned by @code{make_stuff ()}) may
soon get freed as well.

But, here is the problem: the C @code{stuff_container_t} object still
contains a pointer to that @code{stuff_t} object that has just been
deleted!  The goal of the @code{aggregated} typespec is to solve
situations like this one.  In the example above, the wrapped function
and the container type should be specified as follows:

@lisp
(wrap-as-wct! ws
              #:name '<stuff>
              #:c-type-name "stuff_t *"
              #:c-const-type-name "const stuff_t *"
              #:allowed-options '(aggregated))

...

(wrap-function! ws
                #:name 'make-stuff-container
                #:c-name "make_stuff_container"
                #:returns '<stuff-container>
                #:arguments '(((<stuff> aggregated) stuff)))
@end lisp

Literally, this means: ``the argument @var{stuff} of
@code{make-stuff-container} is @emph{aggregated} by the object
returned by @code{make-stuff-container}; therefore, it may not be GC'd
unless the object returned by @code{make-stuff-container} is GC'd
too.''

@cindex finalization order
Additionally, G-Wrap, in this case, enforces the @emph{finalization
order} of WCPs: even if both the referrer (the
@code{<stuff-container>} object) and its dependency (the @var{stuff}
argument) become unreachable during the same GC phase, G-Wrap makes
sure that their @code{wcp-free-function}s (@pxref{Wrapping a C Pointer
Type}) are called in the right order, i.e., referrer first, dependency
second.

@cindex reference counting
Note that some libraries, such as GTK+, solve this problem by relying
on reference counting: aggregating objects must increment the
reference counter of the objects they refer to.  The @code{aggregated}
type qualifier facility can be seen as a solution for those C
libraries that do @emph{not} use reference counting but have memory
ownership semantics similar to the ones described above.  An example
of such a library is Berkeley DB.


@node Wrapping a C Constant, Wrapping an Enumerate Type, Wrapping a C Function, G-Wrap's High-level API
@subsection Wrapping a C Constant

@deffn method wrap-constant! (wrapset <gw-wrapset>) . args
Add the C constant (either a macro or an enumerate value) defined by
@var{args} to the list of constants to be wrapped by @var{wrapset}.
The arguments in @var{args} must contain the following named
parameters:

@table @code
@item #:name
a symbol that is name given to the C constant in the target language
binding;
@item #:type
a symbol denoting the type of this constant, more precisely the name
of the wrapped-type for the constant's type;
@item #:value
a string representing the constant in C (e.g. @code{"ENOMEM"});
@item #:description
a string describing this constant.
@end table

@end deffn

@node Wrapping an Enumerate Type, Wrapping a C Pointer Type, Wrapping a C Constant, G-Wrap's High-level API
@subsection Wrapping an Enumerate Type

When wrapping a whole C enumerate type, G-Wrap proposes an interface
which is more convenient than @code{wrap-constant!} (@pxref{Wrapping a
C Constant}).

@deffn method wrap-enum! (wrapset <gw-wrapset>) . args
Add the enumerate values defined by @var{args} to the list of
constants to be wrapped by @var{wrapset}.  The arguments in @var{args}
must contain the following named parameters:

@table @code
@item #:name
a symbol that is the name for this wrapped type as used within the
G-Wrap framework;
@item #:c-type-name
a string that is the C name of this enumerate type;
@item #:values
a list of symbol/string pairs defining the mapping between C values
and their counterpart in the target language; each pair's @code{car}
is a symbol representing the name for this value in the target
language; each pair's @code{cdr} is a string representing this value
in C;
@item #:description
an optional description of this enumerate type.
@end table

This can be used as follows:

@example
(wrap-enum! my-wrapset
            #:name 'errcode
            #:c-type-name "errcode_t"
            #:description "The libchbouib error codes."
            #:values '((chbouib/no-memory . "ERR_NO_MEM")
                       (chbouib/not-found . "ERR_NOT_FOUND")
                       (chbouib/invalid   . "ERR_INVALID")))
@end example

@end deffn


@node Wrapping a C Pointer Type, C Types Provided in the Standard Wrapset, Wrapping an Enumerate Type, G-Wrap's High-level API
@subsection Wrapping a C Pointer Type

@cindex wrapped C type
@cindex WCT
@cindex wrapped C pointer
@cindex WCP
G-Wrap comes with a generic wrapped type for wrapping C pointers which
is called the @dfn{wrapped C type}, or @dfn{WCT} for short.  Within
G-Wrap, WCTs are represented by the @code{<gw-wct>} class, defined in
the @code{(g-wrap c-types)} module.  Instances of a WCT are called
@dfn{wrapped C pointers}, or WCPs for short.

Any C pointer type may be wrapped using the @code{wrap-as-wct!}
method.  This method allows to specify a number of useful information
specific to the C pointer type being wrapped, such as what action
should be taken when a WCP gets garbage-collected.

@deffn method wrap-as-wct! (wrapset <gw-wrapset>) . args
Adds the C pointer type defined by @var{args} to the list of types to
be wrapped by @var{wrapset}.  The arguments in @var{args} must contain
the following named parameters:

@table @code
@item #:name
a symbol specifying a Scheme-level name for this type.
@item #:c-type-name
a string representing the C pointer type, such as
@code{"chbouib_t *"}.
@item #:c-const-type-name
a string representing the @code{const}-qualified version of the C
pointer type, such as @code{"const chbouib_t *"}.
@end table

Optionally, @var{args} may contain the following parameters:

@table @code

@item #:wcp-equal-predicate
@findex equal?
A string representing a pointer to a C function of type
@code{int (*) (void *, void *)}.  This C function will be called
whenever comparing, via @code{equal?} (@inforef{Equality, , guile},
for details), two WCP objects of the type being wrapped.  It should
return true (i.e., non-zero) whenever the two C objects pointed to by
the @code{void *} pointers are equal, false otherwise.

@item #:wcp-free-function
A string representing a pointer to a C function of type
@code{size_t (*) (void *wcp)}.  This C function will be called
whenever a WCP of this type is garbaged-collected and will be passed
the C pointer wrapped by this WCP.

@item #:wcp-mark-function
A string representing a pointer to a C function of type
@code{SCM (*) (SCM wcp)}.  This is a non-portable feature that is
relevant only to wrapsets targeting Guile.

@cindex GC
@cindex garbage collector
@cindex mark and sweep
@cindex memory management
Guile's garbage-collector uses a @dfn{mark and sweep} algorithm
(see @inforef{Garbage Collecting Smob, the description of Guile's GC
mechanism, guile}, for details).  This parameter allows to direct the
mark phase for the specific C type being wrapped, using the same
protocol as the one used for SMOBs in Guile.

This option is only useful when wrapping C types that aggregate
objects of type @code{SCM}: during the mark phase of the GC,
@code{SCM} objects referenced by instances of such a type will need to
be marked, too.  Suppose, for instance, the following C type:

@example
typedef struct
@{
  int   count;
  float average;
  SCM   scheme_thing;
@} chbouib_t;
@end example

When the GC marks a WCP wrapping a @code{chbouib_t} pointer, you will
also want it to mark the Scheme object contained in its
@code{scheme_thing} field.  Using @code{#:wcp-mark-function}, you can
specify a mark function for your WCT such that the @code{scheme_thing}
field does get marked.

@item #:description
A string describing this wrapped C type.
@end table


@end deffn

@node C Types Provided in the Standard Wrapset, Wrapping Another Simple C Type, Wrapping a C Pointer Type, G-Wrap's High-level API
@subsection C Types Provided in the Standard Wrapset

@cindex standard wrapset
Beside the generic wrapped C pointer type (WCT) and wrapped enumerate
type, G-Wrap comes with a @dfn{standard wrapset} that includes a
number of commonly used wrappers for C types (@pxref{Wrapsets}).  This
wrapset can be made available by using the @code{(g-wrap ws standard)}
module.

When creating a wrapset that depends on the wrapped types defined in
the standard wrapset, make sure you specify @code{standard} among the
dependencies of you wrapset class as shown in @xref{Wrapsets}.

The table below summarizes the wrapped provided by the standard
wrapset:

@vindex mchars double size_t int

@multitable @columnfractions 0.33 0.33 0.33
@headitem G-Wrap Name @tab C Name @tab Scheme Type

@item @code{void}
@tab @code{void}
@tab unspecified

@item @code{bool}
@tab @code{int}
@tab boolean

@item @code{char}
@tab @code{char}
@tab character

@item @code{float}
@tab @code{float}
@tab inexact number

@item @code{double}
@tab @code{double}
@tab inexact number

@item @code{size_t}
@tab @code{size_t}
@tab exact number

@item @code{int}
@tab @code{int}
@tab exact number

@item @code{unsigned-int}
@tab @code{unsigned int}
@tab exact number

@item @code{mchars}
@tab @code{char *}
@tab string

@end multitable

Similarly, other integer types not listed here are available (e.g.,
@code{short}, @code{unsigned-long-long}, etc.), as well as variants
with a specified ranged (e.g., @code{int8}, @code{unsigned-int32},
etc.).

@cindex strings
@cindex wrapped strings
The type @code{mchars} denotes strings, i.e., null-terminated
character arrays on the C side.  Note that @code{mchars} alone does
not specify any memory ownership semantics.  Therefore, when wrapping
C functions that manipulate strings, you may in turn specify the
memory management semantics that are valid for this functions and the
strings it operates on.  This is done by adding appropriate type
qualifiers to the string argument of the wrapped function, such as
@code{caller-owned} (@pxref{Wrapping a C Function}).


@node Wrapping Another Simple C Type,  , C Types Provided in the Standard Wrapset, G-Wrap's High-level API
@subsection Wrapping Another Simple C Type

If you want to wrap a simple C type which is does not fit in any of
the categories above, then G-Wrap provides a simple high-level
function for that purpose.

@deffn method wrap-simple-type! (wrapset . <gw-wrapset>) . args
Add the type described by @var{args} to the list of types to be
wrapped by @var{wrapset}.  The arguments in @var{args} must contain
the following named parameters:

@table @code
@item #:name
a symbol that is the name for this wrapped type as used within the
G-Wrap framework;
@item #:c-type-name
a string that is the C name of this enumerate type;
@item #:type-check
a list representing C expression that returns true if the given Scheme
value's type is this type; this list may contain strings (representing
part of the C expression) and the @code{scm-var} symbol which will be
expanded to the name of the C variable that holds the Scheme value;
@item #:ffspec
@cindex libffi
a symbol representing the libffi type name that describes this type
best; it may be, for instance, @code{pointer} for pointer types,
@code{long} for long integers, etc.; in other words, this is meant to
provide @dfn{run-time type information}, as described in @xref{Wrapped
Types}.
@item #:unwrap
a list representing a C statement that assigns (and converts) the
value of a C variable holding a Scheme value to a C variable holding
the corresponding C value; as for @code{#:type-check}, this list may
only contain strings and symbols; the symbol @code{scm-var} will be
expanded to the name of the C variable that holds the Scheme value,
while the symbol @code{c-var} will be expanded to the C variables that
will hold the corresponding C value;
@item #:wrap
a list representing a C statement that assigns (and converts) the
value of a C variable holding a C value to a C variable holding the
corresponding Scheme value; the content and interpretation of the list
as the same as for @code{#:unwrap};
@item #:description
an optional description of this type.
@end table

@end deffn

@cindex SCM
@cindex scm
As an example, the simple @code{scm} wrapped type which lets the user
wrap C functions that take or return raw @code{SCM} objects (see
@inforef{The SCM Type, Guile's SCM type, guile}, for a description of
Guile's C type for Scheme objects) is defined as follows:

@lisp
(wrap-simple-type! wrapset
                   #:name 'scm
                   #:c-type-name "SCM"
                   #:type-check '("1") ;; any Scheme value is correct
                   #:ffspec 'pointer
                   ;; no conversion is needed
                   #:unwrap '(c-var " = " scm-var ";\n")
                   #:wrap '(scm-var " = " c-var ";\n"))
@end lisp

If @code{wrap-simple-type!} is still not good enough for what you want
to do, then you may have a look at the details of G-Wrap's code
generation interface, @xref{G-Wrap's Code Generation API}.


@node G-Wrap's Code Generation API,  , G-Wrap's High-level API, API Reference
@section G-Wrap's Code Generation Interface

When creating Scheme bindings for a C programming interface with
G-Wrap, one first needs to create a @dfn{wrapset} (@pxref{Wrapsets}).
Once a wrapset has been created and wrapped types and functions have
been added to it, G-Wrap is ready to proceed with the generation of
C code implementing these wrappings.

In the following sections, we will detail the @dfn{protocol} that is
used to perform code generation.  G-Wrap heavily uses GOOPS, Guile's
object orientation framework, to this end (@inforef{Top, GOOPS,
goops}).  This is what makes G-Wrap highly customizable: each of these
code generation methods may be overloaded or redefined in order to
meet the user's particular needs.

Most of the classes and methods involved in generation of C code are
defined in the @code{(g-wrap c-codegen)}.

@menu
* Overview of the Code Generation Methods::  
* The Top-Level Methods::       
* Wrapping and Unwrapping Values::  
@end menu

@node Overview of the Code Generation Methods, The Top-Level Methods, G-Wrap's Code Generation API, G-Wrap's Code Generation API
@subsection Overview of the Code Generation Methods

@cindex code generation methods
Unless stated otherwise, the code generation methods all have a name
ending in @code{-cg}.  Most of them take a wrapset as their first
argument (i.e. instances of a sub-class of @code{<gw-wrapset>}), some
of them don't.

@cindex code tree
All code generation methods must return a @dfn{code tree}, that is a
list whose elements are either strings, lists of strings, or a special
forms.  The strings and list of strings must be valid C code.  Special
forms are lists that are automatically expanded to produce C code when
a tree is written to a file.  The valid special forms are the
following:

@deffn {Special CG Form} gw:error? c-error-var [error-value]
This special form expands to C code that tests whether the C variable
named @var{c-error-var} (a string) denotes a G-Wrap error status.  If
@var{error-value} is provided, it must be a symbol denoting one of the
various G-Wrap run-time error conditions:

@table @code
@item misc
an error condition that does not fit in the other names;
@item memory
a memory management exception;
@item range
a range exception (e.g. for integer conversion);
@item type
a type exception (e.g. wrong return type);
@item argc
a wrong-number-of-arguments exception;
@item arg-range
a range exception for one of the arguments;
@item arg-type
a type exception for one of the arguments.
@end table

If @var{error-value} is provided, this special form expands to code
that checks whether the C variable named @var{c-error-var} denotes an
error condition equal to @var{error-value}.
@end deffn

@deffn {Special CG Form} gw:error error-type [args]
Expands to C code that raises a G-Wrap run-time error of type
@var{error-type}, with error-specific arguments @var{args}.
@var{error-type} must be a symbol whose value is one of those
described above.
@end deffn


@node The Top-Level Methods, Wrapping and Unwrapping Values, Overview of the Code Generation Methods, G-Wrap's Code Generation API
@subsection The Top-Level Methods

As we have just seen, wrapset objects (i.e. instances of a sub-class
of @code{<gw-wrapset>}) are the most complex objects manipulated when
using G-Wrap: they aggregate a number of objects providing information
about what is to be wrapped.  Consequently, the top-level code
generation methods are those that apply to wrapset themselves.

@deffn method generate-wrapset (lang <symbol>) (name <symbol>) (basename <string>)
@findex get-wrapset
This method generates a wrapset call @var{name}, for language run-time
@var{lang}, and using @var{basename} as the base for the names of the
generated files.  This is the highest-level method in G-Wrap.  It will
actually lookup a registered wrapset with name @var{name} (using the
@code{get-wrapset} method which returns a @code{<gw-wrapset>} object)
and invoke the method described below.
@end deffn

@deffn method generate-wrapset (lang <symbol>) (wrapset <gw-wrapset>) (basename <string>)
Generate wrapper code for the wrapset @var{wrapset} for language
run-time @var{lang}.  The generated files will named using
@var{basename} as a base name: the name of C source files will be the
concatenation of @var{basename} and @code{".c"}, etc.  Currently,
@var{lang} may be either @code{guile} (when generating wrappers for
GNU Guile) or @code{scheme48} (when generating wrappers for the
Scheme48 system).
@end deffn


The default implementation of @code{generate-wrapset} will in turn
call a number of methods whose purpose is to generate the necessary
file includes, global declarations and definitions for each C file.
These methods are listed below in the order in which they are
invoked at code-generation time.

@deffn method before-includes-cg
Return a tree of C code to be inserted before any @code{#include}
directive.
@end deffn

@deffn method global-declarations-cg (wrapset <gw-wrapset>)
Return a tree of C code that contains global declarations needed for
wrapset @var{wrapset}.
@end deffn

@deffn method global-definitions-cg (wrapset <gw-wrapset>)
Return a tree of C code that contains global definitions needed for
wrapset @var{wrapset}.
@end deffn

@deffn method declarations-cg (wrapset <gw-wrapset>)
Return a tree of C code that contains declarations of local variables
for the wrapset run-time initialization function.  By default, the
generated wrapset run-time initialization function is named
@code{gw_initialize_wrapset_WRAPSET} where @code{WRAPSET} is the name
of the wrapset it initializes (actually a C-compatible representation
of it).
@end deffn

FIXME: To be continued.

@node Wrapping and Unwrapping Values,  , The Top-Level Methods, G-Wrap's Code Generation API
@subsection Wrapping and Unwrapping Values

For each specific wrapped type, a specific sequence of C code must be
issued to @dfn{wrap} (i.e. convert a C value to a Scheme value) and
@dfn{unwrap} (i.e. convert a Scheme value to C) values of this type.
The high-level API offers a way to specify this via
@code{wrap-simple-type!} (@pxref{Wrapping Another Simple C Type}).
However, G-Wrap's native code generation protocols is much more
flexible that this.

The methods described below are those that direct the generation of
wrapping/unwrapping C code for values of a given wrapped type.

@deffn method wrap-value-cg (type <gw-type>) (value <gw-value>) err (inlined? <boolean>)
Generate C code that wraps the value @var{value} of type @var{type}.
@var{err} is a string containing the name of the C variable holding a
G-Wrap run-time error (@pxref{Overview of the Code Generation
Methods}).

If @var{inlined?} is false, then this means that the wrapping code is
generated for use in a stand-alone wrapping function for @var{type}.
Generation of code for stand-alone wrapping functions is performed by
@code{wrap-value-function-cg} (see below).

If @var{inlined?} is true, then this means that wrapping code is
generated for use @emph{within} a C function wrapper.  C function
wrapper code generation is performed by @code{function-wrapper-cg} for
functions where run-time type information cannot be relied on (FIXME:
xref).

When wrapping code is generated within a function wrapper, then
certain assumptions can be made that cannot be made in the case of
stand-alone wrapping functions.  For instance, it can be assumed that
storage for the wrapped value can be allocated on the stack rather
than on the heap, in order to speed up operation.

As an example, @code{unwrap-value-cg} method for type @code{mchars},
for Guile wrapsets, can convert Scheme strings to C strings on the
stack using @code{scm_to_locale_stringbuf} rather than
@code{scm_to_locale_string} which allocates a new C string on the
heap (@inforef{Conversion to/from C, Guile string wrapping/unwrapping,
guile}, for details).
The @var{inline?} argument is optional.  This means that you can
overload @var{wrap-value-cg} without having to specify this argument:

@lisp
(define-method (wrap-value-cg (type <my-own-type>) (value <gw-value>)
                              error-var)
  ;; Always generate the same code, whether it is generated in a
  ;; stand-alone wrapping function or not.
  )
@end lisp

@end deffn

@deffn method unwrap-value-cg (type <gw-type>) (value <gw-value>) err (inlined? <boolean>)
Generate C code that unwraps the value @var{value} of type
@var{type}.  @var{err} is a string containing the name of the C
variable holding a G-Wrap run-time error.

The interpretation of @var{inlined?} is the same as for
@code{wrap-value-cg} and it is also optional.
@end deffn

@deffn method destroy-value-cg (type <gw-type>) (value <gw-value>) err (inlined? <boolean>)
Generate C code that destroys the value @var{value} of type
@var{type}.  @var{value} is assumed to be a C value previously
unwrapped by the code generated by @code{unwrap-value-cg}.  @var{err}
is a string containing the name of the C variable holding a G-Wrap
run-time error.

The interpretation of @var{inlined?} is the same as for
@code{wrap-value-cg} and it is also optional.
@end deffn


@cindex RTI
@cindex run-time type information
@deffn method wrap-value-function-cg (type <gw-rti-type>)
Generate a stand-alone C function that wraps values of type
@var{type}, a type for which information is available at run-time.

@cindex libffi
Since G-Wrap allows to construct function calls at run-time via libffi
(FIXME: xref), such stand-alone wrapping functions are used by the
run-time call constructor.
@end deffn


@c Chapter ==================================================================
@node Concept Index, Type and Class Index, API Reference, Top
@unnumbered Concept Index

@printindex cp

@node Type and Class Index, Procedure and Method Index, Concept Index, Top
@unnumbered Type and Class Index

@printindex tp

@node Procedure and Method Index,  , Type and Class Index, Top
@unnumbered Procedure and Method Index

@printindex fn

@contents
@bye

@c Local Variables:
@c ispell-local-dictionary: "american"
@c End:
